\chapter{Details zur Lösung / Evaluation} 
\label{chapter:Kapitel6}
\lhead{Kapitel 6. \emph{Details zur Lösung / Evaluation}}  

\section{Entwicklungsumgebung und eingesetzte Werkzeuge}\label{section:entwicklungsumgebungen_tools}
Für die Entwicklung von Plesynd wurden unterschiedliche Tools und Frameworks genutzt. Entwickelt wurde das System auf Serverseite mit \href{http://php.net}{PHP}\footnote{\url{http://php.net}}. Der clientseitige Code wurde mit \href{http://de.wikipedia.org/wiki/Javascript}{Javascript}\footnote{\url{http://de.wikipedia.org/wiki/Javascript}} implementiert. Die für die entwicklung von Plesynd eingesetzten Frameworks werden im Folgenden kurz vorgestellt.

\subsection{AngularJS}\label{section:angularjs}
Plesynd ist eine größtenteils clientbasierte Applikation. Für die Implementierung des Systems fiel die Wahl auf das von Google entwickelte Javascript-Framework \href{http://angularjs.org/}{AngularJS}\footnote{\url{http://angularjs.org/}}. Im Gegensatz zu anderen JS Frameworks verfolgt AngularJS für die Umsetzung des User Interfaces einen Ansatz, welcher am einfachsten als eine Erweiterung der Möglichkeiten von HTML zu beschreiben ist. Hierfür bietet AngularJS sogenannte Direktiven. Direktiven erlauben die deklarative Angabe von Kontrollstrukturen wie Schleifen (inklusive Filtermechanismen) und konditionalen Anweisungen innerhalb des HTML-Codes. AngularJS ist in der Lage dieses erweiterte HTML zu parsen, auszuwerten und dem Anwender die Ergebnisse zu präsentieren. Der Entwickler kann auch eigene Direktiven für weitere DOM-Manipulation entwickeln. Neben den Direktiven bietet AngularJS die Möglichkeit sogenannte Controller zu erstellen. In diesen Controllern wird die eigentliche Programmlogik ausgeführt. Ein Controller wird (ebenfalls über eine Direktive) einem beliebigen DOM-Knoten zugewiesen. Auf die Variablen, die innerhalb des Controllers definiert wurden kann dann im Inhalt des DOM-Elements zugegriffen werden. Durch die Funktionalität des sogenannten "`Two-Way-Data-Bindings"' sorgt AngularJS dafür, dass eine Änderung der Variable innerhalb des Controllers direkt im User Interface sichtbar wird. Ändert der Anwender auf der anderen Seite den Wert einer so gebundenen Variable (z.B. über ein Formularfeld), so spiegelt sich diese Änderung direkt im Wert der Variable im Controller wieder. Somit erreicht Angular eine saubere Trennung zwischen der Business-Logik der Anwendung, dem User Interface und der manchmal recht komplexen Manipulation von DOM-Elementen. Funktionalitäten, welche in mehreren Controllern oder auch in Direktiven benötigt werden, lassen sich in sogenannten Services implementieren. Mögliche Anwendungsfälle hierfür sind unter anderem das Kapseln von HTTP-Requests oder die Arbeit mit einem Offline-Storage. Zusammenfassend bietet AngularJS:
\begin{itemize}
 \item \emph{Direktiven} zur Manipulation des DOM.
 \item \emph{Controller} zur Ausführung der Programmlogik und Reaktion auf Nutzereingaben
 \item \emph{Services} zur Kapselung von Funktionalitäten, die an multiplen Stellen benötigt werden
\end{itemize}
Es ist natürlich ohne weiteres möglich, dass Abhängigkeiten zwischen den einzelnen Bestandteilen existieren. Ein Controller benötigt z.B. zumeist unterschiedliche Services für den korrekten Ablauf der Programmlogik. Diese Abhängigkeiten werden deklarativ angegeben. AngularJS sorgt dann per Dependency-Injection-Mechanismus dafür, dass die Objekte ihrer Abhängigkeiten erhalten. AngularJS bietet noch einige andere Funktionalitäten, wie z.B. ein Event-System und das Beobachten beliebiger Objekt-Eigenschaften, welche jedoch aus Platzgründen hier nicht weiter vorgestellt werden.

Im Folgenden verdeutlicht ein kurzes Beispiel die Arbeit mit AngularJS. Das Beispiel ist an dem für die Arbeit entwickelten Todo-Widget angelehnt. Es zeigt einen Controller und einen Ausschnitt HTML-Quellcode.

\begin{lstlisting}
Application.Controllers.controller('TodoCtrl', ['$scope', 'todoService', function ($scope, todoService) {
  $scope.todos = [
    {id: 1, content: 'Todo 1', completed : false},
    {id: 2, content: 'Todo 2', completed : false},
    {id: 3, content: 'Todo 3', completed : true},
  ];
  
  $scope.newTodo = '';

  $scope.addTodo = function () {
    if ($scope.newTodo.length === 0) { return; }

    var todo = {title : $scope.newTodo, completed : false,};

    todoService.post(todo, function () {
      $scope.todos.push(todo);
      $scope.newTodo = '';
    });
  };
  
  $scope.todoCompleted = function (todo) {
    todo.completed = !todo.completed
    todoService.put(todo);
  };
});
\end{lstlisting}
Der Controller hat den Namen \texttt{TodoCtrl}. Seine Definition verlangt die Injektion zweier Services. Zum einen des AngularJS internen \texttt{\$scope} Service, zum anderen des eigenen \texttt{todoService}. Alle Variablen, die im Controller definiert werden und im HTML zur Verfügung stehen sollen, werden dem \texttt{\$scope} Objekt als Eigenschaften zugewiesen. Hierzu gehören einige Todo-Objekte (welche auch vom Server geholt werden könnten) ein String für ein neues Todo und zwei Funktionen zum Hinzufügen und Bearbeiten von Todos. Das folgende HTML wird über die Direktive \texttt{ng-controller} mit dem Controller verknüpft.

\begin{lstlisting}
<div ng-controller="TodoCtrl">
 <table>
  <tr>
   <td colspan="2">
    <form ng-submit="addTodo()">
     <input type="text" placeholder="What needs to be done?" ng-model="newTodo" autofocus>
    </form>
   </td>
  </tr>
  <tr ng-repeat="todo in todos>
   <td>
    <i ng-hide="todo.completed" class="icon-ok" ng-click="todoCompleted(todo)"></i>
    <i ng-show="todo.completed" class="icon-remove" ng-click="todoCompleted(todo)"></i>
   </td>
   <td>
    <strong>Title: {{todo.title}} (Id: {{todo.id}})</strong>
   </td>
  </tr>
 </table>
</div>
\end{lstlisting}
Im HTML wird die Direktive ng-repeat dazu genutzt, die im Controller hinterlegten Todo Objekte zu durchlaufen. Mit der Klammersyntax (z.b. {{todo.title}}) wird der Wert einer Variable oder einer Objekteigenschaft ausgegeben. Die Direktiven \texttt{ng-show} und \texttt{ng-hide} blenden ein DOM-Element ein oder aus, wenn angegebene Bedingung zu \texttt{true} auswertet. Mit einem Klick auf ein Icon, welches mit der \texttt{ng-click} Direktive ausgezeichnet wurde, wird die \texttt{todoCompleted} Methode im Controller aufgerufen, welches das aktuelle Todo-Objekt aktualisiert. Das im oberen Teil des Quellcodes abgebildete Formular dient zum Hinzufügen eines neuen Todo-Objektes. Das Input-Feld wird mit der \texttt{ng-model} Direktive mit der Variable \texttt{\$scope.newTodo} verknüpft. Trägt der Anwender etwas in das Formularfeld ein ändert sich diese Variable automatisch im Controller. Im Controller wird sie mit einem leeren String initialisiert, so dass im Formularfeld kein vorausgefüllter Wert steht. Beim Abschicken des Formulars wird die in der \texttt{ng-submit} Direktive angegebene Methode \texttt{\$scope.addTodo} aufgerufen, welche auf Basis des eingebenen Wertes für \texttt{\$scope.newTodo} und mit Hilfe des \texttt{todoService} ein neues Todo-Objekt erstellt und zur Kollektion hinzufügt. Auf Grund des oben erwähnten "`Two-Way-Data-Bindings"' wird das neue Todo automatisch in die über \texttt{ng-repeat} erstellte Liste der Todos aufgenommen. Der Entwickler muss sich nicht um etwaige DOM-Manipulationen kümmern, so dass die Anwendungslogik hiervon völlig frei bleibt.

\subsection{Symfony2}\label{section:symfony2}
\href{http://symfony.com}{Symfony2}\footnote{\url{http://symfony.com}} ist ein in PHP implementiertes komponentenbasiertes Framework zur Entwicklung von MVC(Model-View-Controller) Anwendungen. Zu den bereitgestellten Komponenten gehört beispielsweise ein \href{http://symfony.com/doc/current/book/service_container.html}{Service Container}\footnote{\url{http://symfony.com/doc/current/book/service_container.html}}. Dieser erlaubt es die von den genutzten Klassen benötigten Abhängigkeiten zu definieren. Der Container sorgt dann für eine Instantiierung der Abhängigkeiten und ein Injizieren\footnote{Dies ist eine Art der Umsetzung des Dependency Injection Design-Patterns. Dieses Muster wird dazu verwendet, um eine stärkere Entkopplung zwischen einzelnen Objekte in der objektorientierten Programmierung zu erreichen. Anstatt die Abhängigkeiten fest in einer Klasse zu verankern (in dem das benötigte Objekt in der Klasse instantiiert wird), gibt die Klasse entweder im Konstruktor oder in Setter-Methoden nur das Interface des benötigten Objektes an. Dies ermöglicht ein einfacheres Austauschen der eigentlichen Implementierung und kann insbesondere die Arbeit mit Unit Tests erleichtern (vgl. \cite{Fowler2004})} dieser zur Laufzeit. Des weiteren bietet Symfony2 unter anderem die eigene Template-Engine \href{http://twig.sensiolabs.org/}{Twig}\footnote{\url{http://twig.sensiolabs.org/}}, sowie ein Event-Listener System, welches ermöglicht auf bestimmte Events zu reagieren. Ein Beispiel hierfür wäre das \texttt{onKernelResponse} Event, welches in der Lage ist die Antwort, die das System an den Client schickt noch zu verändern um beispielsweise zusätzliche Header zu setzen (dieser Mechanismus wird beispielsweise vom \texttt{NelmioCorsBundle} genutzt, um die in Kaptitel \ref{section:same_origin_policy} beschriebene CORS-Systematik zu implementieren). Das Model wird in Symfony2 standardmäßig über Doctrine2 (siehe \ref{section:doctrine2}) abgebildet.
Die Komponenten werden in Symfony2 über sogenannte \href{http://symfony.com/doc/current/cookbook/bundles/best_practices.htmlBundles}{Bundles}\footnote{\url{http://symfony.com/doc/current/cookbook/bundles/best_practices.htmlBundles}} implementiert. Bundles sind von dem System unabhängige Plugins, mit einer festen Verzechnisstruktur, welche einfach in eine Applikation eingebunden werden können. Das besondere an Symfony2 ist, dass das gesamte System aus Bundles aufgebaut ist. Hierzu gehören also auch das Kern-Framework, alle Komponenten, zusätzlicher Third-Party-Code, sowie die eigene Applikation selbst.

\subsection{Doctrine2}\label{section:doctrine2}
Für die serverseitige Speicherung der unterschiedlichen Daten (Workspace, Widgets, Todos etc.) wird Doctrine2 genutzt. Doctrine2 ist ein Werkzeug zur objektrelationalen Abbildung von einfachen Objekten in relationale Datenbanken (object-relational-mapping: ORM). Doctrine2 nutzt im Gegensatz zu vielen anderen ORM-Systemen, nicht das Active-Record-Pattern, sondern das Data-Mapper-Pattern. Der entscheidende Unterschied hierbei ist der, das die Objekte selber keine Methoden besitzen, mit denen sie in der Datenbank hinterlegt oder gefunden werden können, sie können als einfach Objekte ohne besondere Fähigkeiten implementiert werden (vgl. \cite{Fowler2002}). Diese Arbeit übernimmt eine Abstraktionsebene zwischen den Objekten und der Datenbank, bei Doctrine2 ein sogenannter Entity-Manager. Dieser ist in der Lage ist zu erkennen, ob bestimmte Objekte schon in den Speicher geladen wurden. Ist dies nicht der Fall kann er sie mitsamt eventueller Verknüpfungen aus der Datenbank in den Speicher laden und dem System zur Verfügung stellen. Somit können die Objekte sich allein mit der Geschäftslogik des Systems beschäftigen, wodurch eine bessere Entkopplung der Zuständigkeiten (Geschäftslogik und Speichern in einer relationalen Datenbank) der einzelnen Teile des Systems erreicht wird.

\subsection{Jquery}
\href{http://jquery.com/}{Jquery}\footnote{\url{http://jquery.com/}} ist eine Javascript-Bibliothek zur einfachen Manipulation des DOM. Desweiteren stellt sie erweiterte Javascript-Funktionalitäten zur Verfügung und vereinfacht die Arbeit mit den browserbasierten Event-System AngularJS verwendet Jquery, wenn vorhanden, insbesondere zur Manipulation des DOM. In Plesynd basiert unter anderem das Postmessage-Plugin (siehe \ref{section:kommunikation_zwischen_iframes_implementierung}) auf Jquery. AngularJS nutzt Jquery, wenn es vorhanden ist zur DOM-Manipulation. Ist Jquery nicht geladen benutzt es hierfür eine eigenes rudimentäres Plugin.

\subsection{Twitter Bootstrap}
\href{http://twitter.github.com/bootstrap/}{Twitter Bootstrap}\footnote{\url{http://twitter.github.com/bootstrap/}} ist ein von Twitter entwickeltes Framework zur schnellen und einfachen Entwicklung von Frontends. Es stellt CSS-Vorlagen und Javascript-Komponenten zur Verfügung, welche es dem Entwickler ermöglichen sollen in kurzer Zeit ein User-Interface zu entwerfen und umzusetzen. Bootstrap beinhaltet CSS-Vorlagen für Grids, Tabellen, Buttons etc. . In Plesynd wird von den von Bootstrap zur Verfügung gestellten Javascript-Komponenten momentan nur die \href{http://twitter.github.com/bootstrap/javascript.htmlmodals}{Modal-Komponente}\footnote{\url{http://twitter.github.com/bootstrap/javascript.htmlmodals}} verwendet. 

\section{Implementierungsdetails}\label{section:implementierungsdetails}

\subsection{eigene Symfony2 Bundles}\label{section:backend}
Für die Umsetzung von Plesynd wurden auf der Serverseite fünf Symfony2-Bundles implementiert: Diese werden im Folgenden kurz vorgestellt.

\begin{itemize}
\item Das \emph{CorujaPlesyndBundle} bildet das Herzstück des Plesynd-System. Es enthält die zentralen \texttt{Workspace}- und \texttt{Widget}-Entitäten, in denen der größte Teil der Geschäftslogik für die Arbeit mit Plesynd abgebildet wird. Zusätzlich gibt es noch Controller, die für die \texttt{Workspace}- und \texttt{Widget}-Controller, welche die REST-Anfragen des Clients entgegen nehmen und abarbeiten und den \texttt{Plesynd}-Controller welcher für das initiale Bereitstellen der benötigten Daten zuständig ist. Hier findet man auch die Javascript-Dateien, welche für die Arbeit mit den Widgets, den Workspaces und dem Dashboard notwendig sind.
\item Zur Kommunikation mit Wookie (siehe \ref{section:w3c_widgets}) wurde das \emph{CorujaWookieConnectorBundle} entwickelt. Dieses integriert das \href{http://wookie.apache.org/docs/embedding.html}{Wookie Connector Framework}\footnote{\url{http://wookie.apache.org/docs/embedding.html}} und versetzt das CorujaPlesyndBundle in die Lage direkt Anfragen an Wookie zu versenden. Das Bundle ist über die normale Symfony2 Konfiguration konfigurierbar, so dass es in der Lage ist mit unterschiedlichen Wookie-Instanzen zu kommunizieren.
\item Das \emph{CorujaUserBundle} basiert auf dem FOSUserbundle (TodoLink) und ist für das User-Management in Plesynd zuständig.
\item Im \emph{CorujaAngularModuleBundle} werden die AngularJS-Implementierungen hinterlegt, welche sowohl für das Plesynd-System, als auch für zusätzliche Widgets verwendet werden können. Hierzu gehören insbesondere das System, welches für die Offline-Fähigkeiten zuständig ist, aber auch Services für die Inter-Frame-Kommunikation oder die Verwendung von HttpXmlRequests in Formularen.  
\item Für eine prototypische Implementierung eines offlinefähigen Widgets wurde das \emph{CorujaTodoBundle} entwickelt. Dieses arbeitet mit dem Todo-Widget zusammen, nimmt dessen REST-Anfragen entgegen und bearbeitet diese. Für das User-Management nutzt es ebenfalls das CorujaUserBundle.
\end{itemize}

\subsection{Umsetzung der Offline-Fähigkeiten}

\subsubsection{Information über Änderung des Online-Status}
Die Applikation wird über ein globales Event an zentraler Stelle darüber informiert, wenn sich der Online-Status des Browser ändert:
\begin{lstlisting}
// bei Erstaufruf der Applikation
.run(['$rootScope', '$window', function ($rootScope, $window) {
    // Status wird auf online geändert, offline funktioniert analog
    $window.addEventListener("online", function () {
        $rootScope.$apply(function () {
            // sende internes Event an alle Listener
            $rootScope.$broadcast('onlineChanged', true);
        });
    }, true);
\end{lstlisting}

Als Reaktion darauf wird ein internes Event ausgelöst, welches von den jeweiligen Listenern verarbeitet werden kann. Beispielsweise können die Controller mit der Änderung einer Variable reagieren, welche dann für die Ausblendungen von DOM-Elementen im Offline-Modus genutzt werden können (siehe \ref{section:einschraenkungen_im_offline_betrieb}):
\begin{lstlisting}
// im Plesynd Controller
$rootScope.$on('onlineChanged', function (evt, isOnline) {
  [...]
  $scope.isOnline = isOnline;
  [...]
});
\end{lstlisting}

\subsubsection{Local Storage Api}\label{section:local_storage_api}
Wie oben beschrieben ist Plesynd in der Lage zu erkennen, wenn das System offline genutzt wird. Ist dies der Fall werden keine Requests mehr an den Server gesendet, sondern die Daten werden im Local-Storage (siehe \ref{section:offline_storage}) gespeichert. Für diese Funktionalität sind hauptsächlich zwei entwickelte AngularJS-Services zuständig: \texttt{CorujaResourceService} und \texttt{CorujaLocalStorageService}. Da diese Services global genutzt und von allen Widgets und Applikationen eingebunden werden müssen, die die Offline-Fähigkeiten von Plesynd nutzen wollen, sind diese im CorujaAngularModuleBundle hinterlegt. Der \texttt{CorujaLocalStorageService} ist für das
Speichern der Daten im Local-Storage zuständig. Der \texttt{CorujaResourceService} kapselt den \texttt{CorujaLocalStorageService} und ein AngularJS \texttt{\$ressource}-Service-Objekt, welches eines Abstraktionsebene für REST-Anfragen an einen Server darstellt. Der \texttt{CorujaResourceService} erkennt mit Hilfe des \texttt{CorujaOnlineStatusService}, ob das System zum Zeitpunkt einer Anfrage online oder offline ist und benutzt dann je nach Situation einen oder beide gekapselten Services zum Ausführen der Anfrage. Ist das System offline wird nur der \texttt{CorujaLocalStorageService} verwendet. Ist das System online wird ein Request an den Server gesendet, Damit das System bei einem Ausfall der Internetverbindung weiter arbeiten kann wird ebenfalls der Local-Storage akutalisiert. Tritt aus irgend einem Grund ein Fehler bei der Kommunikation mit dem Server auf wird die Anfrage trotzdem im Local-Storage hinterlegt. Der \texttt{CorujaResourceService} wird ebenfalls verwendet, um die Synchronisation zwischen dem Local-Storage und dem Server vorzunehmen, sobald das System wieder online ist. 

Im folgenden Beispiel sieht man einen Ausschnitt der Bearbeitung einer PUT Anfrage, also dem Update einer Ressource, bei dem das eben beschriebene Prinzip zum Einsatz kommt:
\begin{lstlisting}
resource.put = function (item, success, error) {
    resourceDeferred = $q.defer();
    var promise = resourceDeferred.promise;

    // wenn nicht online, schreibe in Local-Storage
    if (!onlineStatus.isOnline()) {
        resource.localFallback(item, 'put', success, error);
        return promise;
    }

    // sende Anfrage an Server
    remoteResource.put(item,
        function (data, header) {
	    // update Local-Storage im Erfolgsfall
            resource.updateLocalStorage(item, 'put');
            resourceDeferred.resolve();
            (success || noop)(item, header);
        }, function (response) {
	    // speichere auch im Local-Storage bei Fehler
            resource.localFallback(item, 'put', success, error, response);
        });
    return promise;
}; 
\end{lstlisting}
\texttt{CorujaLocalStorageService} stellt für die Arbeit mit Ressourcen ein Interface bereit, welches an die im REST Kapitel (\ref{section:rest}) beschriebenen HTTP-Methoden angelehnt ist:
\begin{lstlisting}           
interface ResourceStorage {
  // holt alle Ressourcen anhand der Parameter
  array query(array params, callback success, callback error)
  
  // holt eine Ressource anhand der Parameter
  object get(array params, callback success, callback error) 
  
  // erstellt eine neue Ressource
  promise post(object item, callback success, callback error)
  
  // updated eine Ressource
  promise put(object item, callback success, callback error) 
  
  // entfernt eine Ressource
  promise delete(object item, callback success, callback error) 
  
  // Synchronisiert den Local-Storage mit dem Server
  void synchronize(callback success, callback error)
};             
\end{lstlisting}

Damit die Offline-Funktionalität für einen vom Server zur Verfügung gestellten Ressourcentyp (z.B. Todo, Todo-Liste, Widget, Workspace) genutzt werden kann, muss für jeden Typ ein eigener Service auf Basis des beschriebenen Interfaces implementiert werden. Dieser Service kapselt den oben beschriebenen \texttt{CorujaResourceService} und stellt eine API für die Arbeit mit diesen Ressourcen in den Controllern, Services und Direktiven bereit. Die Services für die einzelnen Ressourcentypen können, müssen aber nicht diese Methoden zur Nutzung in einem Controller freigeben. Sie können diese auch umbennen oder eigene Methoden hinzufügen, müssen diese dann jedoch intern auf Basis des \texttt{ResourceStorage} Interfaces implementieren. Innerhalb der Controller wird nur mit diesem Service gearbeitet, für den Entwickler ist die Unterscheidung zwischen Onlinestatus und Offlinestatus in dieser Hinsicht also vollkommen transparent. Im Folgenden werden Auszüge aus dem \texttt{TodoService} gezeigt, welcher den \texttt{CorujaResourceService} wie beschrieben nutzt. Zuerst wird der Local-Storage und der Service für die Rest-Anfragen konfiguriert und auf Basis dieser Konfiguration eine Instanz der \texttt{CorujaResourceService} erstellt. Dieser wird dann in den Methoden query, put, synchronize etc. verwendet. Die hier definierten Methoden stehen dann in einem Controller zur Verfügung, wenn dieser den \texttt{TodoService} als Abhängigkeit angibt (siehe Listing in Kapitel \ref{section:angularjs}).
\begin{lstlisting}
Application.Services.factory('todoService', function ($resource, [...], localStorage, resourceService,  configuration) {
  [...]
  // Konfigurere den Local Storage und den $resource Service
  config = {
    remoteResource : $resource(configuration.TODO_RESOURCE_URI, {todoId:'@id'}, {
      put:{method:'PUT' },
      post:{method:'POST' }
    }),
    localResource : localStorage(local_storage_prefix),
    // dieser Service benutzt Synchronisation
    use_synchronization : true
  };   
  // erstelle auf Basis der Konfiguration eine Instanz des resourceService
  resource = resourceService(config);
    
  service.query = function (success, error) {
    return resource.query({}, success, error);
  }; 
  [...]
  service.put = function (item, success, error) {
      resource.put(item, success, error).then(resolver, resolver);
  };  
  service.synchronize = function (success, error) {
      resource.synchronize(success, error);
  };
  return service;
}]);
\end{lstlisting}

\subsubsection{Einschränkungen im Offline-Betrieb}\label{section:einschraenkungen_im_offline_betrieb}
Trotz der Offline-Fähigkeiten des System stehen im Offline-Betrieb nicht alle Funktionalitäten zur Verfügung. Hauptaugenmerk wurde auf die Weiterbenutzbarkeit der Widgets im Offline-Modus gelegt. Im Folgenden sind einige Funktionen aufgelistet, welche während des Offline-Betriebes deaktiviert werden.
\begin{itemize}
 \item Hinzufügen, Bearbeiten und Löschen von Widgets
 \item Hinzufügen, Bearbeiten und Löschen von Workspaces
 \item Drag and Drop von Widgets
 \item Anlegen und Bearbeiten von Todo-Listen im Todo-Widget
\end{itemize}
 Die Funktionalitäten werden meist einfach über eine \texttt{ng-show} Direktive ausgeblendet, sobald das System feststellt, dass es sich im Offline-Modus befindet. Im folgenden Listing wird beispielsweise die Funktionalität zum Löschen von Widgets aus Workspaces aus dem User Interface entfernt:
\begin{lstlisting}
<ul class="nav pull-right">
 <li>
  <a ng-show="isOnline" ng-click="deleteWidget(widget)">
   <span class="label label-important">x</span>
  </a>
 </li>
</ul>
\end{lstlisting}

\subsubsection{Preloads der Widgets}
Plesynd muss den User in die Lage versetzen nach einmaligem Laden des Systems offline weiterzuarbeiten. Dies ist nur möglich, wenn alle Daten beim erstmaligen Aufruf geladen werden. Insbesondere gilt dies für die iframes der Widgets. Es müssen die Appcache-Dateien der einzelnen Widgets geladen werden und das Dashboard benötigt die Infos der Widgets zur Ausgabe der zusammenfassenden Informationen direkt bei Systemstart. Der Nutzer soll sich nicht erst durch alle vorhandenen Workspaces bewegen müssen, um die Daten aller Widgets zu laden. Aus diesem Grund müssen die iframes aller Widgets aller Workspaces bei dem ersten Aufruf im DOM vorhanden sein. Des weiteren dürfen die iframes bei Wechsel zwischen den Workspaces nicht wieder aus dem DOM entfernt werden. Der Grund hierfür ist, dass bei Wechsel des Online-Status alle iframes aktualisiert werden müssen und nicht nur diejenigen des aktuellen Workspaces.

Aus diesen Gründen wurde entschieden alle iframes bei Systemstart direkt zu laden und im DOM vorzuhalten. Es findet lediglich eine Filterung auf Basis des anzuzeigenden Workspace statt, welche der iframes ausgegeben werden und welche ausgeblendet werden.
\begin{lstlisting}
// im Controller
$scope.isWidgetVisible = function (widget) {
  return widget.workspace.id === $scope.activeWorkspace.id;
};

// im HTML
<div ng-repeat="widget in widgets" ng-show="isWidgetVisible(widget)" ...>
\end{lstlisting}

\subsection{Widgets auf Hauptebene}
Die ursprüngliche Archtiektur von Plesynd sah vor, dass der Local-Storage nur direkten Zugriff auf die Hauptdatensätze liefert. Dies dies hätte zur Folge, dass nur Workspaces direkt referenziert werden könnten. Der Zugriff auf die Widgets würde dann über ihre Workspaces erfolgen. Das entwickelte Storage/Resource System kann auf Grund der Einfachheit des Local-Storage jedoch nur mit Hauptdatensätzen arbeiten. Dieses Vorgehen hat jedoch einige Probleme und Fragen nach sich gezogen: 
\begin{itemize}
 \item Wie kann man lokal mit Subdatensätzen arbeiten, wenn man keinen direkten Zugriff auf sie hat? Es ist nicht ohne weiteres möglich aus dem Local-Storage eines Workspaces ein Widget zu löschen oder zu bearbeiten. Der Workspace müsste geholt, das Widget in dem Workspace gelöscht/bearbeitet und der Workspace wieder geschrieben werden. 
 \item Als Rest Service wäre es kein Problem direkt Widgets zu löschen oder zu bearbeiten, aber dies geht nicht ohne weiteres im Local-Storage. Der Local-Storage muss aber geupdatet werden, damit das System auch offline mit den korrekten Daten arbeitet.
\end{itemize} 

Es gibt mehrere Möglichkeiten dieses Problem zu lösen:
\begin{enumerate}
 \item\label{enumerate:widgets_hauptebene_indexed_db} Umstellung auf eine andere Lösung zur lokalen Speicherung der Daten (z.B. IndexedDb)
 \item\label{enumerate:widgets_hauptebene_erweiterung_local_storage} Erweiterung der Implementierung zur Speicherung der Daten im Local-Storage, so dass auch Subeinträge gefunden und bearbeitet werden können.
 \item\label{enumerate:widgets_auf_hauptebene} Speicherung der Subdatensätze auf der Hauptebene. Alle direkt über die REST-Schnittstelle ansprechbaren Resourcen werden auf der Hauptebene im Local-Storage hinterlegt, Widgets werden also auch auf der Hauptebene im Local-Storage gespeichert.
\end{enumerate}
Punkt \ref{enumerate:widgets_hauptebene_indexed_db} sollte auf Grund der höheren Komplexität vermieden werden. Punkt \ref{enumerate:widgets_hauptebene_erweiterung_local_storage} kam in die engere Betrachtung wurde jedoch verworfen, da er die Komplexität der Speicherung in den Local-Storage beträchtlich erhöht hätte. Wie in \ref{section:plesynd_architektur} beschrieben, sollte es für die Implementierung der Logik unerheblich sein, ob das System zum Zeitpunkt einer Nutzeraktion online oder offline ist. Um dies mit Punkt \ref{enumerate:widgets_hauptebene_erweiterung_local_storage} zu erreichen, hätte die in \ref{section:local_storage_api} vorgestellte Vorgehensweise grundlegend geändert werden müssen. Aus diesen Gründen wurde Punkt \ref{enumerate:widgets_auf_hauptebene} umgesetzt. Jede REST-Resource wird direkt auf der Hauptebene abgelegt. Somit ergibt sich eine einfach 1:1 Abbildung der Resourcen auf den Local-Storage. 

\subsection{Probleme bei multiple Instanzen des selben Widgets}
Es ist möglich, dass das selbe Widget mehrfach in einer Plesynd-Instanz verwendet wird. Beispielsweise könnte das TodoList-Widget auf mehreren Workspaces verwendet werden, um je nach Kontext unterschiedliche Todo-Listen zu verwalten. Es können hierbei jedoch Synchronisationsprobleme auftreten, wenn beide Widget-Instanzen offline auf der selben Datenbasis operieren. Der Grund dafür liegt darin, dass die POST-Methode nicht idempotent ist (siehe \ref{section:rest}). Da die unterschiedlichen Widget-Instanzen nicht in Kommunikation miteinander stehen, bedeutet dies im Falle einer Synchronisierung, dass beide Instanzen lokal hinzugefügte Datensätze per POST an den Server schicken. Somit entstehen nicht gewollte Dopplungen der Datensätze. DELETE und PUT Aufrufe stellen für diesem Fall keine Probleme dar, da diese Methoden idempotent sind und ein doppelter DELETE Request an eine Resource keine negativen Auswirken hat. Dieses Problem wurde gelöst, in dem jede Widget-Instanz seinen eigenen Local-Storage zur Speicherung seiner Daten erhält. Der Name des Local-Storage ergibt sich aus dem internen Namen des Widgets (beispielsweise todo) konkateniert mit dem Namen des iframes in dem das Widge aufgerufen wird. Der Name des iframes ergibt sich aus der ID, welche Wookie für jedes Widgets erstellt. Diese ID ist einzigartig und verändert sich auch bei wiederholtem Aufrufen nicht. Somit ist sichergestellt, dass jedes Widget einen festen Local-Storage erhält.

Es ist natürlich möglich, dass unterschiedliche Widget-Instanzen zwar unterschiedlichen Local-Storage benutzen, jedoch auf der selben Datenbasis arbeiten (beispielsweise die selben Todo-Listen verwenden). Da momentan noch keine Inter-Widget Kommunikation stattfindet, kann es hierbei zu Problemen kommen, wenn im Offline Betrieb beispielsweise ein Datensatz in einer Instanz gelöscht wird, während er in einer anderen bearbeitet wurde. Dieses Problem wurde im Rahmen dieser Arbeit nicht weiter betrachtet und sollte eventuell in Folgearbeiten bearbeitet werden.

\subsection{Drag'n Drop}
Zur Umsetzung des Drag and Drop Funktionalität zum Sortieren der Widgets auf einem Workspace wurde das \href{http://jqueryui.com/sortable/}{Sortable Widget}\footnote{\url{http://jqueryui.com/sortable/}} der \href{http://jqueryui.com}{JqueryUi-Bibliothek}\footnote{\url{http://jqueryui.com}} verwendet. Diese wurde in einer eigenen AngularJS-Direktive gekapselt, so dass das JqueryUi-Widget in der bestehenden Architektur verwendet werden konnte. Die Direktive verwendet den Widget-Service, um die neue Position der Widgets dem Server mitzuteilen und den OnlineStatus-Service, um die Drag and Drop Funktionalität im Offline-Modus zu deaktivieren.

\subsection{CORS}\label{section:cors_implementierung}
In einer Mashup-Anwendungen wie Plesynd ist es unumgänglich, dass XMLHttp Requests benötigt werden. Insbesondere die Wookie-Instanz und dadurch die Origin aller Widgets hat eine Origin als das eigentlich Plesynd System. Aus diesem Grund benötigt Plesynd eine CORS (siehe Kapitel \ref{section:same_origin_policy}) Implementierung. Zur Vereinfachung der Umsetzung wird das \href{https://github.com/nelmio/NelmioCorsBundle}{NelmioCorsBundle}\footnote{\url{https://github.com/nelmio/NelmioCorsBundle}} verwendet. Dieses erlaubt in der Systemkonfiguration die gewünschten Einstellungen vorzunehmen. Im Folgenden wird beispielhaft die Konfiguration für das Todo-Widget gezeigt: 
\begin{lstlisting}
nelmio_cors:
  paths:
    '^/(todo/api|login|logout)':
      allow_origin: ['*']
      allow_headers: ['X-REQUESTED-WITH', 'Content-Type', 'Authorization']
      allow_methods: ['POST', 'PUT', 'GET', 'DELETE', 'OPTIONS'],
      expose_headers: ['Location']
\end{lstlisting}
Alle Requests, die an eine URI gehen, welche mit /todo/api oder /login oder /logout beginnen wird hierbei erlaubt von einer anderen Quelle zu kommen. Es werden die Header und Methoden definiert, welche in einem solchen Request erlaubt sind. Der Location Header wird bei Antwort dem Client wieder zur Verfügung gestellt. Dieser wird benutzt, um nach dem Erstellen einer neuen Ressource per POST die URI der Ressource an den Client zu übermitteln. 

\subsection{Kommunikation zwischen den iframes}\label{section:kommunikation_zwischen_iframes_implementierung}
Sobald ein neues offlinefähiges Widget einem Workspace hinzugefügt wird, meldet sich dieses bei Plesynd an. Nun ist es möglich, dass es Plesynd über die in dem Widget verwalteten Datensätze informiert wird. Da die Widgets als iframes realisiert wurden, welche eine andere Origin als Plesynd benutzen, muss das Postmessage System (siehe Kapitel \ref{section:same_origin_policy}) zur Interframe-Kommunikation implementiert werden. In Plesynd wird hierbei das \href{https://github.com/daepark/postmessage}{postmessage}\footnote{\url{https://github.com/daepark/postmessage}} Jquery Plugin genutzt. Dieses stellt Methoden bereit, welche das Binden an Nachrichten-Events und das Versenden von Nachrichten erlauben. Die Widgets-Seite registriert sich bei Erstaufruf mit Plesynd und kann später die Nachrichtenfunktion des \texttt{childFrameMessenger}-Services benutzen:
\begin{lstlisting}
// bei Erstaufruf
.run([..., 'childFrameMessenger', function (..., childFrameMessenger) {
    childFrameMessenger.registerWithParent();
    
// im TodoService, nach Hinzufuegen eines TodoService
service.post = function (item, success, error) {
  resource.post(item, success, error);
  service.notifyParentAboutItems();
};
   
// Definition im childFrameMessenger Service //

// registriere bei Plesynd
ChildFrameMessenger.prototype.registerWithParent = function () {
    pm({
        target : $window.parent,
        type   : "register_child_frame",
        data   : {id : this.name}
    });
};

// sende Infos an Plesynd
ChildFrameMessenger.prototype.notifyParentAboutItems = function (data) {
    data.id = this.name;
    pm({
        target : $window.parent,
        type   : "notify_about_items",
        data   : data
    });
};
\end{lstlisting}

Plesynd ist in der Lage auf die versendeten Nachrichten zu hören und dann die Informationen im Dashboard und in der Kopfzeile der einzelnen Widgets darzustellen:
\begin{lstlisting}
// Definition im ParentFrameMessenger Service
ParentFrameMessenger.prototype.initialize = function () {
    // Listener: Registrieren von Widgets
    pm.bind("register_child_frame", function (child) {
        if (child['id'] != undefined) {
            $rootScope.$broadcast("childFrameRegistered", child);
        }
    });

    // Listener: eingehende Daten
    pm.bind("notify_about_items", function (data) {
        if (data['id'] != undefined) {
            $rootScope.$broadcast("incomingFrameData", data);
        }
    });
};
\end{lstlisting}

\section{Evaluation}



\section{Use Case}

Die Arbeit mit einer solchen Lernumgebung kann durch die folgenden Use-Cases beschrieben werden.

Das Ziel der vorliegenden Arbeit ist die Planung und Implementierung eines Prototypen für eine leichtgewichtige Personal-Learning-Environment. Die Anforderungen an das finale System lassen sich aus dem in dem nächsten Abschnitt vorgestellten Use-Case ableiten, welcher die Arbeit mit dem System verdeutlichen soll.
Der folgende Use-Case soll durch das finale System idealerweise abgedeckt werden:

\subsection{Akteure}

\begin{itemize}
 \item Dozent mit Sitz in Hagen
 \item Student 1 mit Sitz in Kamerun (Fernuni Hagen)
 \item Student 2 mit Sitz in Kamerun (Fernuni Hagen)
 \item Student 3 mit Sitz in Berlin (Fernuni Hagen)
 \item Student 4 mit Sitz in Osnabrück (Universität Osnabrück) 
\end{itemize}

\subsection{Ausgangssituation}\label{section:ausgangssituation}
Der Dozent betreut an der Fernuni Hagen unter anderem den Kurs "`E-Learning: A new approach"'. Hierfür haben auch die Studenten 1 und 3 eingeschrieben. Für diesen Kurs hat der Dozent mehrere Kanäle zur Kommunikation angelegt. Die Studenten sollen die Kanäle wählen, die ihren Arbeitsgewohnten am meisten entsprechen. Am Ende des Semesters soll es eine Auswertung geben, welche Kanäle am häufigsten genutzt und welche von den Studenten eher ignoriert wurden. Parallel dazu werden die Systeme der Fernuni zur Online Bearbeitung der Einsendeaufgaben genutzt. Die vom Dozenten angelegten Kommunikationskanäle sind:

\begin{itemize}
 \item ein Twitter Channel
 \item eine Facebookgruppe
 \item einen eigenen Google-Calender
 \item einen Chat
 \item zur Terminabsprache und Abstimmung der nächsten Schritte soll Doodle verwendet werden
 \item ein System zur Hinterlegung von Todo-Listen
 \item einen eigenen Blog, welcher einen RSS Feed bereitstellt 
 \item Etherpad Lite soll zur gemeinsamen Erstellung von Texten genutzt werden
\end{itemize}

Die Studenten sind angehalten sich regelmäßig über Aktualisierungen der Kanäle auf dem Laufenden zu halten.

Zusätzlich haben sich Student 1, 2 und 4 zu einer virtuellen Lerngruppe zum Thema Datenbanken zusammengeschlossen. Hierfür können nicht die Systeme der Fernuni Hagen genutzt werden, da nur Student 2 momentan in dem spezifischen Kurs eingeschrieben ist. Student 1 hat sich nicht für den Kurs angemeldet und Student 4 hat überhaupt keine Möglichkeit dazu, da er nicht an der Fernuni immatrikuliert ist. Sie haben sich dazu entschlossen primär einen Chat zur Kommunikation zu benutzen.

\subsubsection{Einschränkungen/Umstände}
Student 1 und Student 2 leben in Kamerun. Beide haben dort das Problem, dass der Internetzugriff aus mehreren Gründen nicht immer gegeben ist. Student 1 hat zu Hause keinen Internetzugang. Er hat nur die Möglichkeit in der Universität oder in einem Internetcafe online zu gehen. Student 2 hat einen Internetzugang, allerdings ist dieser relativ langsam und wird nach Zeit abgerechnet, so dass es vorteilhaft für ihn ist, wenn er nur für kurze Zeit online ist. Aus diesem Grund benötigen die beiden idealerweise ein System, welches ihnen die Möglichkeit bietet die neuesten Informationen auch offline zu lesen und zumindest rudimentär auch offline kleine Aufgaben zu erledigen. Diese sollten sich bei Wiederverbindung mit dem Internet mit den entsprechenden Services synchronisieren. Des Weiteren sollten sie in der Lage sein die Daten auch ohne Internetverbindung zwischen verschiedenen Rechnern auszutauschen. Insbesondere Student 1 sollte in der Lage seine Aktionen bei sich zu Hause vorzunehmen und die durchgeführten Änderungen dann an einem Rechner mit Internetanschluss zu synchronisieren. Die Anforderungen von Student 3 sind ähnlich gelagert. Er ist sehr viel unterwegs und erledigt daher viele kurze Aufgaben mit dem Smartphone. Auch hier ist eine Internetverbindung nicht immer gewährleistet ist oder sie wird temporär deaktiviert um die Akkulaufzeit zu verlängern. Durch die Arbeit an unterschiedlichen Rechnern mit potentiell unterschiedlichen Betriebssystemen, ist die Installation einer komplexen Software nicht ohne Weiteres möglich.

Idealerweise nutzen alle Studenten das selbe Basissystem und können sich hier die benötigten Services und Applikationen so zusammenstellen wie es ihren Ansprüchen entspricht.

\subsection{Arbeitsabläufe}
Im Folgenden werden die unterschiedlichen Arbeitsabläufe mit dem System exemplarisch an Student 1 und an Student 3 dargelegt.

\subsubsection{Grundsätzlicher Arbeitsablauf für Studenten}
Um mit der PLE arbeiten zu können müssen die Studenten als erstes online eine Account in dem PLE-System erstellen. Anschließend melden sie sich mit ihren gewählten Login-Daten an. Bei erfolgreicher Anmeldung hat der Anwender die Möglichkeit direkt Workspaces zu erstellen, mit diesen zu arbeiten (Workspace umbenennen, Einstellungen vornehmen, Widgets hinzufügen etc).

\subsubsection{Arbeitsablauf Student 1}
\begin{itemize}
 \item \emph{Tag 1:} Student 1 befindet sich in der Universität und verbindet seinen USB-Stick mit einem PC. Auf diesem Stick befindet sich die ausführbare mobiler Version eines aktuellen Browsers. Er öffnet die Applikation online in diesem Browser (alle folgenden Aktionen werden mit dem selben Browser durchgeführt). Student 1 erstellt einen neuen Workspace und benennt ihn in "`PLE"' um. Anschließend sucht er die Widgets für den PLE Workspace aus der Widget-Datenbank heraus. Das System zeigt ihm dabei an, für welche Widgets eine Offline-Fähigkeit zur Verfügung steht. Daraufhin organisiert er die Anordnung der Widgets nach seinen Vorstellungen per Drag and Drop neu. Damit er mit den einzelnen Widgets auch arbeit kann meldet sich Student 1 schließlich bei den jeweiligen Services mit seinen Account-Daten an. Bevor er den Browser schließt haben sich alle Widgets mit ihren Services synchronisiert und zeigen ihm dies auch an.
 \item \emph{Tag 2:} Student 1 loggt sich an der Uni in das PLE-System ein. Das System zeigt ihm auf der Startseite (dem Dashboard) an wie viele neue Items es auf seinem PLE Workspace gibt. Ein direkter Link führt ihn zum Workspace. Er sieht, dass momentan mehrere Leute im Chat sind und unterhält sich über das Widget mit ihnen. Der Dozent hat einige globale Todos angelegt und die ersten Nachrichten kommen über den Twitter Channel herein. Nach einiger Zeit klickt Student 1 auf “jetzt offline gehen” wodurch alle Widgets seines Workspaces auf den neuesten Stand gebracht werden. Er sieht, dass Student 3 einen längeren Text im Chat geschrieben hat, beschließt diesen jedoch später zu lesen. Gleiches gilt für den Einführungsartikel des Dozenten im Kursblog. Hierfür erstellt er sich Items in seiner Todo-Liste. Abschließend schließt Student 1 den Browser und entfernt den USB-Stick.
 \item \emph{Tag 3:} Student 1 öffnet die Applikation in seinem mobilen Browser zu Hause. Das System erkennt, dass es sich im Offline-Modus befindet und versucht keine Synchronisierung mit dem Internet herzustellen. Student 1 liest den Text, den Student 3 im Chat hinterlegt hat und beantwortet die darin gestellten Fragen ebenfalls im Chatfenster. Anschließend teilt er dies über Twitter mit und erledigt sein Todo-Item.
 \item \emph{Tag 4:} Student 1 loggt sich im Internet-Cafe mit seinem mobilen Browser in das System ein. Das System erkennt, dass es online ist, lädt die neuesten Items der Services herunter und synchronisiert die nur lokal vorgenommenen Aktionen (Twitter, Chat, Todo). Per Mail hat Student 1 den Vorschlag von Student 2 bekommen gemeinsam mit Student 4 eine Lerngruppe zum Thema Datenbanken zu gründen. Hierzu wollen sie unter anderem ein Chat-System benutzen. Student 1 schlägt per Mail das ihm bekannte Chat-Widget für die PLE-Applikation vor. Er erstellt einen neuen Workspace, nennt ihn “Lerngruppe DB” und fügt das Chat-Widget mit den passenden Einstellungen hinzu.
 \item \emph{Tag 5:} Student 1 sieht in seinem Dashboard, dass es für den Workspace “Lerngruppe DB” 12 neue Items gibt. Er geht direkt zu dem Workspace und stellt fest, dass die beiden anderen Studenten sich ebenfalls in dem Chat angemeldet haben. Da momentan alle online verfügbar sind, beginnen sie ihre erste Gruppenunterhaltung und planen die weitere Vorgehensweise.
\end{itemize}

\subsubsection{Arbeitsablauf Student 3}
Student 3 nutzt das System hauptsächlich mit seinem Tablet, welches in der Lage ist sich über Wlan, sowie UMTS mit dem Internet zu verbinden.

\begin{itemize}
 \item \emph{Tag 1:} Student 3 meldet sich ähnlich wie Student 1 in der PLE an und erstellt für seine Uni-Kurse jeweils einen Workspace. Außerdem legt er sich einen Workspace an, in dem sich nicht kursspezifische Widgets finden. Hierzu gehören sein Google-Kalender, sein RSS-Reader, eine Todo Liste, sowie ein News-Widget
 \item \emph{Tag 2:} Student 3 verbindet sich zu Hause mit seinem Wlan und loggt sich in der PLE ein. Nach Prüfung des Dashboards erstellt er sich in der allgemeinen Todo Liste für den Tag. Er sieht, dass es in seinem RSS-Reader 9 neue Artikel gibt. Diese möchte er auf seinem Weg zur Uni in der U-Bahn lesen. Da dort der Empfang eher schlecht ist, synchronisiert er die PLE noch einmal. Auf dem Weg zu Uni ruft Student 3 das System auf seinem Tablet auf. Da kein Internetzugang besteht greift das System nur auf die lokalen Daten zurück. Das News-Widget in seinem globalen Workspace ist nicht offline-fähig. Aus diesem Grund wird es auch nur ausgegraut und nicht-funktional angezeigt. Der Student ist jedoch in der Lage seine lokal gecachten RSS-Artikel zu lesen. Bei Lektüre eines Artikels über Javascript fällt ihm ein, dass er sein Uni-Projekt noch mit der neuesten JQuery Version updaten wollte. Hierzu erstellt er sich ein weiteres Todo auf seiner Liste.
 In der Uni verbindet er sein Tablet mit dem Uni-Wlan. Der RSS-Reader markiert die 6 Artikel die, Student 3 in der U-Bahn gelesen hat als gelesen und synchronisiert das neueste Todo-Item mit dem Service im Internet.  
\end{itemize}

\section{Anforderungen}\label{section:anforderungen_summary}
Zusammenfassend kann also gesagt werden, dass Betreuer und Studenten stehen über unterschiedliche Kanäle in Kommunikation miteinander stehen. Es müssen Termine geplant oder auch Notizen und Nachrichten hin und hergeschickt werden. Diese Kanäle sollen auf einem zentralen Zugang so zusammengefasst sein, dass es den Teilnehmern des Kurse alle relevanten Informationen an einer aufrufen und bearbeiten zu können. Dabei sind die Teilnehmer zu unterschiedlichen Zeiten online. Die Teilnehmer sollen das System offline Nutzen können, um einfache Arbeiten wie das Schreiben von Twitter-Nachrichten, Notizen und Instant-Messaging Nachrichten oder eine Terminabsprache über einen Kalender erledigen können. Bei dem Wechsel zwischen Online und Offline müssen die Daten synchronisiert werden. Idealerweise haben die Nutzer alle Daten auf einem USB-Stick bei sich und können so von unterschiedlichsten Rechnern, wie beispielsweise in der Universität, im Internetcafe oder zu von Hause aus, arbeiten.

Daraus lassen sich mehrere Anforderungen an das zu entwickelnde System ableiten. Es soll in der Lage sein als Aggregator für die unterschiedlichsten Services und Kanäle zu dienen. Es muss möglich sein auf die wichtigsten Informationen an einem zentralen Platz zuzugreifen und diese auch zu bearbeiten (Anforderung 1). Dadurch, dass die Teilnehmer an unterschiedlichen Rechnern arbeiten, welche zum Teil nicht in ihrem persönlichen Besitz sind, ist es für sie nicht oder nur sehr schwer möglich eine neue Software zu installieren. Aus diesem Grund soll das System mit nativen Browsertechnologien ohne weitere Installation nutzbar sein (Anforderung 2). Das System muss in der Lage die wichtigsten Funktionalitäten auch dann zu Verfügung zu stellen, wenn es keinen Kontakt zu dem Internet hat (Anforderung 3). Des Weiteren soll es in der Lage sein bei einer Wiederaufnahme der Verbindung die durchgeführten Aktionen mit dem jeweiligen Service zu synchronisieren (Anforderung 4). Dies gilt insbesondere für die Arbeit mit unterschiedlichen Rechnern. Der Nutzer soll sein System an einem Computer mit dem Internet synchronisieren können und dann an einem anderen Rechner offline weiterarbeiten können. Es ist also notwendig, dass es dem Nutzer ermöglicht wird die Daten mitzunehmen (beispielsweise per USB-Stick) und an anderer Stelle weiterzuverwenden (Anforderung 5). 

Neben diesen funktionalen Anforderungen gibt es noch weitere Anforderungen, welche das System erfüllen soll. In dieser Arbeit kann nur eine prototypische Implementierung der Anforderungen erfolgen. Das System soll also als Basis für weitere Entwicklungen und Forschungsarbeiten dienen und einfach erweitert und verändert werden können (Anforderung 6). Es soll auch möglich sein auf Basis einer vorgegebenen Implementierung oder API weitere Services oder Kanäle in das System zu laden und es so beständig in seiner Funktionalität zu erweitern (Anforderung 7). Schließlich wird die Software in unterschi Bereichen, insbesondere in einem universitären Umfeld eingesetzt. Dies verlangt eine Nutzbarkeit ohne Lizengebühren für die genutzten Technologien. Daraus folgt, dass für die Umsetzun keine proprietären, sondern nur freie Technologien verwendet werden dürfen (Anforderung 8). 


Die in Abschnitt \ref{section:ausgangssituation} beschriebenen Kanäle und Services müssen für eine vollständige PLE implementiert werden. Da die Umsetzung all dieser aber den Rahmen dieser Arbeit übersteigen würde und das Ziel ist einen Prototypen für die Grundlage einer solchen PLE zu schaffen, werden diese nicht in die Anforderungen aufgenommen.


