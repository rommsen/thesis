\chapter{Details zur Lösung} 
\label{Kapitel 6}
\lhead{Kapitel 6. \emph{Details zur Lösung}}  
Implementierungsdetails (nur die interessanten)
Erfahrungen / Evaluation

\section{Entwicklungsumgebung/Tools}
Für die Entwicklung von Plesynd wurden unterschiedliche Tools und Frameworks genutzt. Entwickelt wurde das System auf Serverseite mit \href{http://php.net}{PHP}\footnote{\url{http://php.net}}. Der Clientseitige Code wurde mit \href{http://de.wikipedia.org/wiki/JavaScript}{JavaScript}\footnote{\url{http://de.wikipedia.org/wiki/JavaScript}} implementiert. 

Die Frameworks im Folgenden kurz vorgestellt.

\subsection{Symfony2}
\href{http://symfony.com}{Symfony2}\footnote{\url{http://symfony.com}} ist ein in PHP implementiertes komponenten-basiertes full-stack Framework zur Entwicklung von MVC(Model-View-Controller) Anwendungen. Zu den bereitgestellten Komponenten gehört beispielsweise ein \href{http://symfony.com/doc/current/book/service_container.html}{Service Container }\footnote{\url{http://symfony.com/doc/current/book/service_container.html}}. Dieser erlaubt es die von den genutzten Klassen benötigten Abhängigkeiten zu definieren. Der Container sorgt dann für ein Instantiieren der Abhängigkeiten und ein Injizieren dieser zur Laufzeit (TODO: Dependendency-Injection erklären?). Desweiteren bietet Symfony2 unter anderem eine eigene Template-Engine (TODO: Twig Link), sowie ein Event-Listener System, welches ermöglicht auf bestimmte Events (TODO: Request Beispiele) zu reagieren. Das Model wird in Symfony2 standardmäßig über Doctrine2 (siehe ~\ref{section:doctrine2}) abgebildet.
Die Komponenten werden in Symfony2 über sogenannte Bundles implementiert (TODO: Bundle Link). Bundles sind von dem System unabhängige Plugins, mit einer festen Struktur, welche einfach in eine Applikation eingebunden werden können. Das besondere an Symfony2 ist, dass das gesamte System aus Bundles aufgebaut ist. Hierzu gehören also auch das Kern-Framework, alle Komponenten, zusätzlicher Third-Party-Code, sowie die eigene Applikation selbst. Die für die Applikation entwickelten Bundles werden in \ref{section:own_bundles}, die Fremd-Bundles in \ref{section:third_party_bundles} beschrieben

\subsection{eigene Bundles}\label{section:own_bundles}
Wichtig: Bundles, was sind Bundles, System komplett aus Bundles aufgebaut. einfaches einbinden von Third Party Bundles. Plesynd besteht aus 3 Bundles: Plesynd, WookieConnector, User (welches wiederum vom FOSUserbundle ableitet. Benutzt noch weitere Bundles: FOSRest (mit Verweis zu Rest Erklärung), NelmioCorsBundle
\subsection{Fremd-Bundles}\label{section:third_party_bundles}

\subsection{Doctrine2}\label{section:doctrine2}
Orm, DataMapper Pattern, kein Active Record, Arbeit mit einfachen Objekten, Entity Manager Unit of Work

\subsection{AngularJS}

\subsection{Jquery}
\href{http://jquery.com/}{Jquery}\footnote{\url{http://jquery.com/}} ist eine JavaScript-Bibliothek zur einfachen Manipulation des DOM. Desweiteren stellt sie erweiterte JavaScript-Funktionalitäten zur Verfügung und vereinfacht die Arbeit mit den browserbasierten Event-System(TODO: ref http://de.wikipedia.org/wiki/JQuery) AngularJS verwendet Jquery, wenn vorhanden, insbesondere zur Manipulation des DOM. In Plesynd basiert unter anderem noch das Postmessage(TODO: ref postmessage) auf Jquery.  

\subsection{Twitter Bootstrap}
\href{http://twitter.github.com/bootstrap/}{Twitter Bootstrap}\footnote{\url{http://twitter.github.com/bootstrap/}} ist ein von Twitter entwickeltes Framework zur schnellen und einfachen Entwicklung von Frontends. Es stellt CSS-Vorlagen und JavaScript-Komponenten zur Verfügung, welche es dem Entwickler ermöglichen sollen in kurzer Zeit ein User-Interface zu entwerfen und umzusetzen. Bootstrap beinhaltet CSS-Vorlagen für Grids, Tabellen, Buttons etc. . In Plesynd wird von den von Bootstrap zur Verfügung gestellten Javascript-Komponenten momentan nur die \href{http://twitter.github.com/bootstrap/javascript.htmlmodals}{Modal-Komponente}\footnote{\url{http://twitter.github.com/bootstrap/javascript.htmlmodals}} verwendet. 

\subsection{Apache Wookie}\label{section:apache_wookie}

\section{Implementierungsdetails}\label{section:implementierungsdetails}

\subsection{Ablauf holen der Daten}
WookieConnectorBundle
Der Loginname  connection getUser() setLoginName(demo2); ist dafür verantwortlich, dass Wookie eine neue Widgetinstanz erstellt oder eine bestehende zurück liefert.

Man muss sich jetzt fragen, ob es möglich sein soll, dass jeder Workspace die selben Instanzen von Widgets hat oder nicht.
Wenn ja, kann einfach die User Id aus Plesynd als identifier genommen werden, wenn nicht, sollte zum Beispiel eine Kombination aus UserId und WorkspaceId als Identifier benutzt werden.

==> eigener unique Identifier beim Widget
jedes Widgets bekommt seinen eigenen localStorage über window.name prefix

\subsection{Api der Offline Services}


\subsection{Preloads der Widgets}
Es ist notwendig, dass alle widgets, aller workspaces bei dem ersten aufruf geladen werden.
Gründe:

    es müssen alle appcache dateien runtergeladen werden, ohne, dass man sich durch alle workspaces klickt,
    das Dashboard benötigt die Infos aller Widgets zur Ausgabe

Wie kann dies umgesetzt werden?


Ich habe keine Wahl als alle iframes immer zu laden und ihre sichtbarkeit zu ändern. Dies wird mir wahrscheinlich ziemlich Probleme mit dem drag and drop geben, aber es geht nicht anders.

Insbesondere beim online/offline Wechsel müssen *alle* iframes aktualisiert werden. Durch den Workspace Wechsel ist es allerdings so, dass angular bei der container arbeitsweise, die iframes immer komplett aus dem dom entfernt. dies bringt dann natürlich gar nichts, da man sich dann immer durch alle Workspaces bewegen müsste


\subsection{Widgets auf Hauptebene}

Worskpace => Widget

Eigentlich ist es so gedacht, dass nur die Hauptentities im LocalStorage gespeichert werden.
Die Widgets würden dann in ihren Workspaces liegen. Das Storage/Resource System kann nur mit Hauptdatensätzen arbeiten, es ist nicht möglich aus einem Workspace ein Widget zu löschen. Der Workspace muss geholt werden, der Eintrag gelöscht werden und der Workspace muss wieder geschrieben werden
Probleme:

    Wie kann man local mit Subentities arbeiten, wenn man keinen direkten Zugriff auf sie hat, man muss immer über die Workspaces gehen
    Als RestService wäre es kein Problem direkt Widgets zu löschen etc, aber dies geht nicht ohne weiteres im Local Storage
    Der Local Storage muss aber geupdatet werden, damit das System auch offline die richtigen Daten hat
    Bei angular Ressourcen kann es nur eine URL geben, dies macht den Rest Zugriff problematisch.

Es gibt mehrere Möglichkeiten dieses Problem zu lösen.

\begin{enumerate}
 \item Umstellung auf eine andere Lösung zur lokalen Speicherung der Daten (z.B. IndexedDb)
 \item Erweiterung der Implementierung zur Speicherung der Daten im Local Storage, so dass auch Subeinträge gefunden und bearbeit werden können.
 \item Speicherung der Subdatensätze auf der Hauptebene.
\end{enumerate}


    

Ich arbeite jetzt so, dass die Widgets in ihrem eigenen Local Storage gespeichert werden. Sie werden dann für die Ausgabe je nach Workspace gefiltert



\subsection{Probleme bei multiple Instanzen des selben Widgets}
Es ist möglich, dass das selbe Widget mehrfach in einer Plesynd-Instanz verwendet wird. Beispielsweise könnte das TodoList-Widget auf mehreren Workspaces verwendet werden, um je nach Kontext unterschiedliche Todo-Listen zu verwalten. Es können hierbei jedoch Synchronisationsprobleme auftreten, wenn beide Widget-Instanzen offline auf der selben Datenbasis operieren. Der Grund dafür liegt darin, dass die POST-Methode nicht idempotent ist (siehe \ref{section:rest}). Da die unterschiedlichen Widget-Instanzen nicht in Kommunikation miteinander stehen bedeutet dies im Falle einer Synchronisierung, dass beide Instanzen lokal hinzugefügte Datensätze per POST an den Server schicken. Somit entstehen nicht gewollte Dopplungen der Datensätze. DELETE und PUT Aufrufe stellen für diesem Fall keine Probleme dar, da diese Methoden idempotent sind und ein doppelter DELETE Request an eine Resource keine negativen Auswirken hat. Dieses Problem wurde gelöst, in dem jede Widget-Instanz seinen eigenen Local-Storage zur Speicherung seiner Daten erhält. Der Name des Local Storage ergibt sich aus dem internen Namen des Widgets (beispielsweise todo) konkateniert mit dem Namen des IFrames in dem das Widge aufgerufen wird.

Es ist natürlich möglich, dass unterschiedliche Widget-Instanzen zwar unterschiedlichen Local Storage benutzen, jedoch auf der selben Datenbasis arbeiten (beispielsweise die selben Todo-Listen verwenden). Da momentan noch keine Inter-Widget Kommunikation stattfindet kann es hierbei zu Problemen kommen, wenn im Offline Betrieb beispielsweise ein Datensatz in einer Instanz gelöscht wird, während er in einer anderen bearbeitet wurde. Dieses Problem wurde im Rahmen dieser Arbeit nicht bearbeitet und sollte eventuell in Folgearbeiten gelöst werden.

\subsection{Cors}

Beschreiben wie Cors umgesetzt, Das NelmioCorsBundle\ref{section:third_party_bundles} wird auf Serverseite eingesetzt um die Arbeit mit Cors zu erleichtern. Es ermöglicht die erlaubten Header über Config Einstellungen (TODO: beispiel) zu definieren und 

\subsection{Kommunikation der IFrames}

Postmessage: 


