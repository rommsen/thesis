\chapter{Details zur Lösung} 
\label{chapter:Kapitel6}
\lhead{Kapitel 6. \emph{Details zur Lösung}}  

\section{Entwicklungsumgebung und eingesetzte Werkzeuge}\label{section:entwicklungsumgebungen_tools}
Für die Entwicklung von Plesynd wurden unterschiedliche Tools und Frameworks genutzt. Entwickelt wurde das System auf Serverseite mit \href{http://php.net}{PHP}\footnote{\url{http://php.net}}. Der clientseitige Code wurde mit \href{http://de.wikipedia.org/wiki/Javascript}{Javascript}\footnote{\url{http://de.wikipedia.org/wiki/Javascript}} implementiert. 

Die für die entwicklung von Plesynd eingesetzten Frameworks werden im Folgenden kurz vorgestellt.

\subsection{Symfony2}
\href{http://symfony.com}{Symfony2}\footnote{\url{http://symfony.com}} ist ein in PHP implementiertes komponentenbasiertes full-stack Framework zur Entwicklung von MVC(Model-View-Controller) Anwendungen. Zu den bereitgestellten Komponenten gehört beispielsweise ein \href{http://symfony.com/doc/current/book/service_container.html}{Service Container }\footnote{\url{http://symfony.com/doc/current/book/service_container.html}}. Dieser erlaubt es die von den genutzten Klassen benötigten Abhängigkeiten zu definieren. Der Container sorgt dann für eine Instantiierung der Abhängigkeiten und ein Injizieren dieser zur Laufzeit (TODO: Dependendency-Injection erklären?). Des weiteren bietet Symfony2 unter anderem eine eigene Template-Engine (TODO: Twig Link), sowie ein Event-Listener System, welches ermöglicht auf bestimmte Events (TODO: Request Beispiele) zu reagieren. Das Model wird in Symfony2 standardmäßig über Doctrine2 (siehe ~\ref{section:doctrine2}) abgebildet.
Die Komponenten werden in Symfony2 über sogenannte Bundles implementiert (TODO: Bundle Link). Bundles sind von dem System unabhängige Plugins, mit einer festen Struktur, welche einfach in eine Applikation eingebunden werden können. Das besondere an Symfony2 ist, dass das gesamte System aus Bundles aufgebaut ist. Hierzu gehören also auch das Kern-Framework, alle Komponenten, zusätzlicher Third-Party-Code, sowie die eigene Applikation selbst.

\subsection{Doctrine2}\label{section:doctrine2}
Für die serverseitige Speicherung der unterschiedlichen Daten (Workspace, Widgets, Todos etc.) wird Doctrine2 genutzt. Doctrine2 ist ein Werkzeug zur objektrelationalen Abbildung von einfachen Objekten in relationale Datenbanken (object-relational-mapping: ORM). Doctrine2 nutzt im Gegensatz zu vielen anderen ORM-Systemen, nicht das Active-Record-Pattern (TODO Fussnote erklären), sondern das DataMapper-Pattern (TODO Fussnote erklären). Der entscheidende Unterschied hierbei ist der, das die Objekte selber keine Methoden besitzen, mit denen sie in der Datenbank hinterlegt oder gefunden werden können. Diese Arbeit übernimmt ein Entity-Manager, welcher in der Lage ist zu erkennen, ob bestimmte Objekte schon in den Speicher geladen wurden und sie sonst aus der Datenbank laden kann. Somit können die Objekte sich allein mit der Geschäftslogik des Systemes Beschäftigung und es wird eine bessere Trennung der Belange (TODO Fussnote erklären) erreicht.

\subsection{AngularJS}
Plesynd ist eine größtenteils clientbasierte Applikation. Für die Implementierung des Systems fiel die Wahl auf das von Google entwickelte Javascript-Framework AngularJS. Im Gegensatz zu anderen JS Frameworks, Parsed Html, logik in Controllern (frei von DOM Manipulation), 2 Wege Data-Binding, One-Page Applications und Services, eigener Direktiven, beispiel ng-show, ng-repeat

\subsection{Jquery}
\href{http://jquery.com/}{Jquery}\footnote{\url{http://jquery.com/}} ist eine Javascript-Bibliothek zur einfachen Manipulation des DOM. Desweiteren stellt sie erweiterte Javascript-Funktionalitäten zur Verfügung und vereinfacht die Arbeit mit den browserbasierten Event-System AngularJS verwendet Jquery, wenn vorhanden, insbesondere zur Manipulation des DOM. In Plesynd basiert unter anderem noch das Postmessage (siehe \ref{section:kommunikation_zwischen_iframes}) auf Jquery.  

\subsection{Twitter Bootstrap}
\href{http://twitter.github.com/bootstrap/}{Twitter Bootstrap}\footnote{\url{http://twitter.github.com/bootstrap/}} ist ein von Twitter entwickeltes Framework zur schnellen und einfachen Entwicklung von Frontends. Es stellt CSS-Vorlagen und Javascript-Komponenten zur Verfügung, welche es dem Entwickler ermöglichen sollen in kurzer Zeit ein User-Interface zu entwerfen und umzusetzen. Bootstrap beinhaltet CSS-Vorlagen für Grids, Tabellen, Buttons etc. . In Plesynd wird von den von Bootstrap zur Verfügung gestellten Javascript-Komponenten momentan nur die \href{http://twitter.github.com/bootstrap/javascript.htmlmodals}{Modal-Komponente}\footnote{\url{http://twitter.github.com/bootstrap/javascript.htmlmodals}} verwendet. 

\section{Implementierungsdetails}\label{section:implementierungsdetails}

\subsection{eigene Symfony2 Bundles}\label{section:backend}
Für die Umsetzung von Plesynd wurden auf der Serverseite fünf Symfony2-Bundles implementiert: Diese werden im Folgenden kurz vorgestellt.

\begin{itemize}
\item Das \emph{CorujaPlesyndBundle} bildet das Herzstück des Plesynd-System. Es enthält die zentralen \texttt{Workspace}- und \texttt{Widget}-Entitäten, in denen der größte Teil der Geschäftslogik für die Arbeit mit Plesynd abgebildet wird. Zusätzlich gibt es noch Controller, die für die \texttt{Workspace}- und \texttt{Widget}-Controller, welche die REST-Anfragen des Clients entgegen nehmen und abarbeiten und den \texttt{Plesynd}-Controller welcher für das initiale Bereitstellen der benötigten Daten zuständig ist. Hier findet man auch die Javascript-Dateien, welche für die Arbeit mit den Widgets, den Workspaces und dem Dashboard notwendig sind.
\item Zur Kommunikation mit Wookie (siehe \ref{section:w3c_widgets}) wurde das \emph{CorujaWookieConnectorBundle} entwickelt. Dieses integriert das \href{http://wookie.apache.org/docs/embedding.html}{Wookie Connector Framework}\footnote{\url{http://wookie.apache.org/docs/embedding.html}} und ist versetzt das CorujaPlesyndBundle in die Lage direkt Anfragen an Wookie zu versenden. Das Bundle ist über die normale Symfony2 Konfiguration konfigurierbar, so dass es in der Lage ist mit unterschiedlichen Wookie-Instanzen zu kommunizieren.
\item Das \emph{CorujaUserBundle} basiert auf dem FOSUserbundle und ist für das User-Management in Plesynd zuständig.
\item Im \emph{CorujaAngularModuleBundle} werden die AngularJS-Implementierungen hinterlegt, welche sowohl für das Plesynd-System, als auch für zusätzliche Widgets verwendet werden können. Hierzu gehören insbesondere das System, welches für die Offline-Fähigkeiten zuständig ist, aber auch Services für die Inter-Frame-Kommunikation oder die Verwendung von HttpXmlRequests in Formularen.  
\item Für eine prototypische Implementierung eines offlinefähigen Widgets wurde das \emph{CorujaTodoBundle} entwickelt. Dieses arbeitet mit dem Todo-Widget zusammen und nimmt dessen REST-Anfragen und bearbeitet diese. Für das User-Management nutzt es ebenfalls das CorujaUserBundle.
\end{itemize}

\subsection{Struktur des Client-Systems}
Vorstellung der wichtigsten eigenen Angular Services und Direktiven (genauer im Anhang)

\subsubsection{Widgetparameter}
Die Parameter für Widgets werden in der Wookie DB hinterlegt.
Die Widget Implementation wird über http://localhost:8080/wookie/shared/js/wookie-wrapper.js ausgeliefert.
Hier ist setItem/getItem ist so implementiert, dass es einen Request an den Server sendet und die Einstellungen speichert.
Die Standardeinstellungen aus der config.xml werden nur beim ersten deploy ausgelesen, anschließend nicht! mehr
Jedes Widget bekommt eine eigene id! Diese kann dann für die Identifizierung genutzt werden.
Die Werte werden NICHT im local storage hinterlegt./

\subsection{Ablauf holen der Daten}
WookieConnectorBundlef
Der Loginname  connection getUser() setLoginName(demo2); ist dafür verantwortlich, dass Wookie eine neue Widgetinstanz erstellt oder eine bestehende zurück liefert.

Man muss sich jetzt fragen, ob es möglich sein soll, dass jeder Workspace die selben Instanzen von Widgets hat oder nicht.
Wenn ja, kann einfach die User Id aus Plesynd als identifier genommen werden, wenn nicht, sollte zum Beispiel eine Kombination aus UserId und WorkspaceId als Identifier benutzt werden.

==> eigener unique Identifier beim Widget
jedes Widgets bekommt seinen eigenen localStorage über window.name prefix


\subsection{Umsetzung der Offline-Fähigkeiten}
Wie in Kapitel \ref{chapter:Kapitel6} beschrieben ist Plesynd in der Lage zu erkennen, wenn das System offline genutzt wird. Ist dies der Fall werden keine Requests mehr an den Server gesendet, sondern die Daten werden im Local-Storage (siehe \ref{section:offline_storage}) gespeichert. Für diese Funktionalität sind hauptsächlich zwei entwickelte AngularJS-Services zuständig: \texttt{resourceService} und \texttt{localStorage}. Da diese Services global genutzt und von allen Widgets und Applikationen eingebunden werden müssen, die die Offline-Fähigkeiten von Plesynd nutzen wollen, sind diese im \texttt{CorujaAngularModuleBundle} hinterlegt. Der \texttt{CorujaLocalStorageService} ist für das speichern zusätndig, benutzt deferreds um mit Angularressource kompatibel zu sein, resourceService kapselt den CorujaLocalStorageService und ein Angular Ressource Objekt. Dieses ist für Rest-Anfragen zusätndig. resourceService erkennt mit Hilfe des OnlineStatusService, ob System online und benutzt entweder das eine oder das andere. Für alle Entitäten, die dies können sollen, muss ein eigener Service geschrieben werden (Beispiel Todo Service), muss Methoden get,post, query, put, delete implemetieren und dem RessourceService die passenden Objekte geben. Innerhalb der Controller wird nur mit diesem Service gearbeitet. Online/Offline dadurch transparent. System hört auf Listener und synchronisiert mit Server, wenn wieder online. Dafür wird ebenfalls der ResourceService genommen.



\subsubsection{Einschränkungen im Offline-Betrieb}
Trotz der Offline Fähigkeiten des System stehen im Offline-Betrieb nicht alle Funktionalitäten zur Verfügung. Hauptaugenmerk wurde auf die Weiterbenutzbarkeit der Widgets im Offline-Modus gelegt. Im Folgenden sind einige Funktionen aufgelistet, welche während des Offline-Betriebes deaktiviert werden.
\begin{itemize}
 \item Hinzufügen, Bearbeiten und Löschen von Widgets
 \item Hinzufügen, Bearbeiten und Löschen von Workspaces
 \item Drag and Drop von Widgets
 \item Anlegen und Bearbeiten von Todo-Listen im Todo-Widget
\end{itemize}
Die Funktionalitäten werden meist einfach ausgeblendet, sobald das System feststellt, dass es sich im Offline-Modus befindet.
(TODO: Codebeispiel)

\subsubsection{Preloads der Widgets}
Plesynd muss den User in die Lage versetzen nach einmaligem Laden des Systems offline weiterzuarbeiten. Dies ist nur möglich, wenn alle Daten beim erstmaligen Aufruf geladen werden. Insbesondere gilt dies für die iframes der Widgets. Es müssen die Appcache-Dateien der einzelnen Widgets geladen werden und das Dashboard benötigt die Infos der Widgets zur Ausgabe der zusammenfassenden Informationen direkt bei Systemstart. Der Nutzer soll sich nicht erst durch alle vorhandenen Workspaces bewegen müssen, um die Daten aller Widgets zu laden. Aus diesem Grund müssen die iframes aller Widgets aller Workspaces bei dem ersten Aufruf im DOM vorhanden sein. Des weiteren dürfen die iframes bei Wechsel zwischen den Workspaces nicht wieder aus dem DOM entfernt werden. Der Grund hierfür ist, dass bei Wechsel des Online-Status alle iframes aktualisiert werden müssen und nicht nur diejenigen des aktuellen Workspaces.

Aus diesen Gründen wurden wurde entschieden alle iframes bei Systemstart direkt zu laden und im DOM vorzuhalten. Es findet lediglich eine Filterung auf Basis des anzuzeigenden Workspace statt, welche der iframes ausgegeben werden und welche ausgeblendet werden
(TODO: Codebeispiel)

\subsection{Widgets auf Hauptebene}
Die ursprüngliche Archtiektur von Plesynd sah vor, dass der Local-Storage nur direkten Zugriff auf die Hauptdatensätze liefert. Dies dies hätte zur Folge, dass nur Workspaces direkt referenziert werden könnten. Der Zugriff auf die Widgets würde dann über ihre Workspaces erfolgen. Das entwickelte Storage/Resource System kann auf Grund der Einfachheit des Local-Storage jedoch nur mit Hauptdatensätzen arbeiten. Dieses Vorgehen hat jedoch einige Probleme und Fragen nach sich gezogen: 
\begin{itemize}
 \item Wie kann man lokal mit Subdatensätzen arbeiten, wenn man keinen direkten Zugriff auf sie hat? Es ist nicht ohne weiteres möglich aus dem Local-Storage eines Workspaces ein Widget zu löschen oder zu bearbeiten. Der Workspace müsste geholt, das Widget in dem Workspace gelöscht/bearbeitet und der Workspace wieder geschrieben werden. 
 \item Als Rest Service wäre es kein Problem direkt Widgets zu löschen oder zu bearbeiten, aber dies geht nicht ohne weiteres im Local-Storage. Der Local-Storage muss aber geupdatet werden, damit das System auch offline mit den korrekten Daten arbeitet.
\end{itemize} 

Es gibt mehrere Möglichkeiten dieses Problem zu lösen:
\begin{enumerate}
 \item\label{enumerate:widgets_hauptebene_indexed_db} Umstellung auf eine andere Lösung zur lokalen Speicherung der Daten (z.B. IndexedDb)
 \item\label{enumerate:widgets_hauptebene_erweiterung_local_storage} Erweiterung der Implementierung zur Speicherung der Daten im Local-Storage, so dass auch Subeinträge gefunden und bearbeitet werden können.
 \item\label{enumerate:widgets_auf_hauptebene} Speicherung der Subdatensätze auf der Hauptebene. Alle direkt über die REST-Schnittstelle ansprechbaren Resourcen werden auf der Hauptebene im Local-Storage hinterlegt
\end{enumerate}
Punkt \ref{enumerate:widgets_hauptebene_indexed_db} sollte auf Grund der höheren Komplexität vermieden werden (TODO: ref auf Entscheidung für Local-Storage). Punkt \ref{enumerate:widgets_hauptebene_erweiterung_local_storage} kam in die engere Betrachtung wurde jedoch verworfen, da er die Komplexität der Speicherung in den Local-Storage beträchtlich erhöht hätte. Wie in \ref{section:technische_umsetzung} beschrieben, sollte es für die Implementierung der Logik unerheblich sein, ob das System zum Zeitpunkt einer Nutzeraktion online oder offline ist. Um dies mit Punkt \ref{enumerate:widgets_hauptebene_erweiterung_local_storage} zu erreichen, hätte die in \ref{section:local_storage_api} vorgestellte Vorgehensweise grundlegend geändert werden müssen. Aus diesen Gründen wurde Punkt \ref{enumerate:widgets_auf_hauptebene} umgesetzt. Jede REST-Resource wird direkt auf der Hauptebene abgelegt. Somit ergibt sich eine einfach 1:1 Abbildung der Resourcen auf den Local-Storage. 

\subsection{Probleme bei multiple Instanzen des selben Widgets}
Es ist möglich, dass das selbe Widget mehrfach in einer Plesynd-Instanz verwendet wird. Beispielsweise könnte das TodoList-Widget auf mehreren Workspaces verwendet werden, um je nach Kontext unterschiedliche Todo-Listen zu verwalten. Es können hierbei jedoch Synchronisationsprobleme auftreten, wenn beide Widget-Instanzen offline auf der selben Datenbasis operieren. Der Grund dafür liegt darin, dass die POST-Methode nicht idempotent ist (siehe \ref{section:rest}). Da die unterschiedlichen Widget-Instanzen nicht in Kommunikation miteinander stehen, bedeutet dies im Falle einer Synchronisierung, dass beide Instanzen lokal hinzugefügte Datensätze per POST an den Server schicken. Somit entstehen nicht gewollte Dopplungen der Datensätze. DELETE und PUT Aufrufe stellen für diesem Fall keine Probleme dar, da diese Methoden idempotent sind und ein doppelter DELETE Request an eine Resource keine negativen Auswirken hat. Dieses Problem wurde gelöst, in dem jede Widget-Instanz seinen eigenen Local-Storage zur Speicherung seiner Daten erhält. Der Name des Local-Storage ergibt sich aus dem internen Namen des Widgets (beispielsweise todo) konkateniert mit dem Namen des iframes in dem das Widge aufgerufen wird. Der Name des iframes ergibt sich aus der ID, welche Wookie für jedes Widgets erstellt. Diese ID ist einzigartig und verändert sich auch bei wiederholtem Aufrufen nicht. Somit ist sichergestellt, dass jedes Widget einen festen Local-Storage erhält.

Es ist natürlich möglich, dass unterschiedliche Widget-Instanzen zwar unterschiedlichen Local-Storage benutzen, jedoch auf der selben Datenbasis arbeiten (beispielsweise die selben Todo-Listen verwenden). Da momentan noch keine Inter-Widget Kommunikation stattfindet kann es hierbei zu Problemen kommen, wenn im Offline Betrieb beispielsweise ein Datensatz in einer Instanz gelöscht wird, während er in einer anderen bearbeitet wurde. Dieses Problem wurde im Rahmen dieser Arbeit nicht weiter betrachtet und sollte eventuell in Folgearbeiten bearbeitet werden.

\subsection{Drag'n Drop}
Zur Umsetzung des Drag and Drop Funktionalität zum Sortieren der Widgets auf einem Workspace wurde das \href{http://jqueryui.com/sortable/}{Sortable Widget}\footnote{\url{http://jqueryui.com/sortable/}} der \href{http://jqueryui.com}{JqueryUi-Bibliothek}\footnote{\url{http://jqueryui.com}} verwendet. Diese wurde in einer eigenen AngularJS-Direktive gekapselt, so dass das JqueryUi-Widget in der bestehenden Architektur verwendet werden konnte. Die Direktive verwendet den Widget-Service, um die neue Position der Widgets dem Server mitzuteilen und den OnlineStatus-Service, um die Drag and Drop Funktionalität im Offline-Modus zu deaktivieren.

\subsection{CORS}
In einer Mashup-Anwendungen wie Plesynd ist es unumgänglich, dass XMLHttp Requests benötigt werden, welche nicht . Insbesondere die Wookie-Instanz und dadurch die Origin aller Widgets hat eine Origin als das eigentlich Plesynd System. Aus diesem Grund benötigt Plesynd eine CORS (siehe Kapitel \ref{section:cors}) Implementierung. Zur Vereinfachung der Umsetzung wird das \href{https://github.com/nelmio/NelmioCorsBundle}{NelmioCorsBundle}\footnote{\url{https://github.com/nelmio/NelmioCorsBundle}} verwendet. Dieses erlaubt in der Systemkonfiguration die gewünschten Einstellungen vorzunehmen. Im Folgenden wird beispielhaft die Konfiguration für das Todo-Widget gezeigt: 
\begin{lstlisting}
nelmio_cors:
    paths:
        '^/(todo/api|login|logout)':
            allow_origin: ['*']
            allow_headers: ['X-REQUESTED-WITH', 'Content-Type', 'Authorization']
            allow_methods: ['POST', 'PUT', 'GET', 'DELETE', 'OPTIONS'],
            # Location Header is used for POST Request Answers (URI of created Item
            expose_headers: ['Location']
\end{lstlisting}
Alle Requests, die an eine URI gehen, welche mit /todo/api oder /login oder /logout beginnen wird hierbei erlaubt von einer anderen Quelle zu kommen. Es werden die Header und Methoden definiert, welche in einem solchen Request erlaubt sind. Der Location Header wird bei Antwort dem Client wieder zur Verfügung gestellt. Dieser wird benutzt, um nach dem Erstellen einer neuen Ressource per POST die URI der Ressource an den Client zu übermitteln. 

\subsection{Kommunikation zwischen den iframes}
Sobald ein neues offlinefähiges Widget einem Workspace hinzugefügt wird, meldet sich dieses bei Plesynd an. Nun ist es möglich, dass es Plesynd über die in dem Widget verwalteten Datensätze informiert wird. Da die Widgets als iframes realisiert wurden, welche eine andere Origin als Plesynd benutzen, muss das Postmessage System (siehe Kapitel \ref{section:kommunikation_zwischen_iframes}) zur Interframe-Kommunikation implementiert werden. In Plesynd wird hierbei das \href{https://github.com/daepark/postmessage}{postmessage}\footnote{\url{https://github.com/daepark/postmessage}} Jquery Plugin genutzt. Dieses stellt Methoden bereit die das Binden an Nachrichten-Events und das Versenden von Nachrichten erlauben. Die Widgets-Seite registriert sich bei Erstaufruf mit Plesynd und kann später die Nachrichtenfunktion des \texttt{childFrameMessenger}-Services benutzen:
\begin{lstlisting}
// bei Erstaufruf
.run([..., 'childFrameMessenger', function (..., childFrameMessenger) {
    childFrameMessenger.registerWithParent();
    
// im TodoService, nach Hinzufuegen eines TodoService
service.post = function (item, success, error) {
            resource.post(item, success, error);
            service.notifyParentAboutItems();
        };
   
   
// Definition im childFrameMessenger Service //

// registriere bei Plesynd
ChildFrameMessenger.prototype.registerWithParent = function () {
    pm({
        target : $window.parent,
        type   : "register_child_frame",
        data   : {id : this.name}
    });
};

// sende Infos an Plesynd
ChildFrameMessenger.prototype.notifyParentAboutItems = function (data) {
    data.id = this.name;
    pm({
        target : $window.parent,
        type   : "notify_about_items",
        data   : data
    });
};
\end{lstlisting}

Plesynd ist in der Lage auf die versendeten Nachrichten zu hören und dann die Informationen im Dashboard und in der Kopfzeile der einzelnen Widgets darzustellen:
\begin{lstlisting}
// Definition im ParentFrameMessenger Service
ParentFrameMessenger.prototype.initialize = function () {
    // Listener für das Registrieren
    pm.bind("register_child_frame", function (child) {
        if (child['id'] != undefined) {
            $rootScope.$broadcast("childFrameRegistered", child);
        }
    });

    // Listener für eingehende Daten
    pm.bind("notify_about_items", function (data) {
        if (data['id'] != undefined) {
            $rootScope.$broadcast("incomingFrameData", data);
        }
    });
};
\end{lstlisting}


