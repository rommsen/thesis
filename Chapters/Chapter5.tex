\chapter{Lösungsansatz} 
\label{Kapitel 5}
\lhead{Kapitel 5. \emph{Lösungsansatz}}  

\section{Überblick - Plesynd}
Das Ziel dieser Arbeit war die Entwicklung eines leichtgewichtigen Prototypen einer Personal Learning Environment, welcher die Anforderungen aus \ref{section:anforderungen_summary} erfüllt. Für die Umsetzung dieses Ansatzes wurde das Hauptaugenmerk auf die Screen- und die Data-Dimension nach Palmér zu gerichtet (siehe Abschnitt \ref{section:dimensions_palmer}). Die Screen-Dimension, also das User-Interface wird in Abschnitt \ref{section:user_interface} beschrieben. Bei der Umsetzung der Data-Dimension handelt es sich primär um die Implementierung der Online-Offline-Fähigkeit des Systems (siehe Abschnitt \ref{section:technische_umsetzung}).

Der Name des Systems lautet Plesynd (Personal-Learning-Environment Synchronize Data) und wird wie das englische "`pleasant"' (angenehm) ausgesprochen. Plesynd ist ein webbasiertes Dashboard, welches die Möglichkeit bietet mit unterschiedlichen Widgets in Kommunikation zu treten. Wichtig ist hierbei eine Abgrenzung zu zentralisierten Lern-Management-Systemen wie Moodle oder Sakai. Die sind sehr kurszentriert und können auch nur schwer mit den Wilson-Patterns für nutzerzentrierte Personal-Learning-Environment Systeme klassifiziert werden (siehe \ref{section:wilson_patterns}). Aus diesem Grund orientiert sich Plesynd viel stärker an bestehenden Widget-Aggregatoren wie iGoogle, Netvibes und Graaasp. Um dem Nutzer die Möglichkeit zu geben in unterschiedlichen Kontexten mit dem System zu arbeiten und so von dem kurszentrierten Ansatz von LM-Systemen zu dem nutzerzentrierten Ansatz von PLEs zu kommen, wird das System dem Nutzer die Möglichkeit geben, seine Widgets in unterschiedliche Bereiche, sogenannte Workspaces, aufzuteilen. Die Anzahl der Workspaces ist frei und jeder Workspace kann individuell benannt werden.

Der entscheidende Unterschied von Plesynd zu den erwähnten Systemen ist die Offline-Fähigkeit der PLE. Es wurde ein Ansatz entwickelt, der es ermöglicht Widgets so zu implementieren, dass ihre Informationen offline verfügbar gemacht werden. Des weiteren kann auch auch offline mit Plesynd und den Widgets weitergearbeitet werden. Sobald wieder eine Online-Verbindung hergestellt ist, werden die veränderten Daten mit dem Backend synchronisiert.

Das Ziel beim Design von Plesynd war es dem Nutzer die Bedienung so einfach wie möglich zu machen. Die wichtigsten Informationen sollten ihm direkt direkt zur Verfügung gestellt werden (sind alle Daten aktuell, welche Widgets werden benutzt, ist das System offline oder online etc). Widgets können gesucht, nach Offline-Kompatibilität gefiltert und dem System hinzugefügt werden. Es existiert ein Dashboard, welches dem Nutzer anzeigt welche Widgets auf welchen Workspaces zur Verfügung stehen und wie ihr Online-/Offline-Status ist. 

\section{User Interface}\label{section:user_interface}
Für die Umsetzung der Screen-Dimension, also des User-Interfaces kommen in Plesynd drei wichtige Konzepte zum Einsatz: Dashboard, Widgets und Workspaces. 

Über Widgets werden die unterschiedlichen Werkzeuge und Services, die ein Nutzer innerhalb des Systems nutzen möchte eingebunden (siehe: Kapitel \ref{section:widgets}). Die Umsetzung der einzelnen Widgets liegt in der Hand des jeweiligen Designers. Da Plesynd Wookie als Widget Container benutzt, ist es möglich alle W3C-Widgets in das System einzubinden. Für diese Arbeit wurde ein Todo-Listen-Service entwickelt für den als prototypische Entwicklung ein Widget mit Online-/Offline-Fähigkeiten implementiert wurde. Besitzt ein Widget Online-/Offline-Fähigkeiten so erhält es eine von Plesynd zur Verfügung gestellte Statusleiste, in der der aktuelle Online-/Offline-Status, sowie die Anzahl der verfügbaren Items und der noch nicht synchronisierten Item angezeigt wird. Der Nutzer hat die Möglichkeit Widgets nach Themen oder Einsatzgebieten zu gruppieren. Dies geschieht über sogenannte Workspaces. Workspaces sind vom Nutzer frei und in unbegrenzter Zahl hinzufügbare Bereiche im System. Sie sind über eine Reiter-Navigation zu erreichen und können jederzeit umbenannt oder auch wieder gelöscht werden. Jedes Widget kann einem Workspace hinzugefügt werden. Die Position der Widgets innerhalb eines Workspaces kann über einen Drag and Drop Mechanismus angepasst werden. Die Startseite stellt als Dashboard die wichtigsten Informationen dar. Jeder Workspace wird in einer eigenen Tabelle inklusive seiner Widgets und der Anzahl der zur Verfügung stehenden Widgets präsentiert. Über direkte Links innerhalb des Dashboards ist es dem Nutzer möglich direkt zu dem gewünschten Workspace zu navigieren.

Diese Konzepte stellen auch die Implementierung einiger der von Wilson definierten Mustern dar, welcher in dem Kapitel \ref{section:wilson_patterns} vorgestellt wurden.  Der "`Discourse Monitor"' (siehe Seite \pageref{wilson_patterns:discourse_monitor}) wird grundsätzlich durch die Startseite, also durch das Dashboard umgesetzt. Diese präsentiert dem Nutzer die wichtigsten Informationen bezüglich seiner Workspaces und gibt ihm durch Links dorthin die Möglichkeit direkt zu den gewünschten Personal-Learning-Tools zu gelangen. Der "`Navigation Layer"' (siehe Seite \pageref{wilson_patterns:navigation_layer}) ist in Plesynd inhärent mit eingebaut. Durch die Einbindung externer Widgets, wird dem User nur der Funktionsumfang zur Verfügung gestellt, welche von den Widget-Entwicklern angedacht wurde. Für den vollen Funktionsumfang muss der Nutzer zum eigentlichen Service des Widgets navigieren. Die Widgets werden über die vom System zur Verfügung gestellten Workspaces aggregiert und in übersichtlicher Form präsentiert. Der Nutzer ist in der Lage Widgets zu seinen frei definierbaren Workspaces hinzuzufügen, zu entfernen oder über Drag and Drop nach seinen Wünschen anzuordnen. Dadurch wird ist auch das "`Choose Change and Discard"'-Pattern (siehe Seite \pageref{wilson_patterns:choose_change_discard}) grundsätzlich im System verankert.

\section{Technische Umsetzung}\label{section:technische_umsetzung}
Plesynd wurde auf der Serverseite mit PHP und auf der Clientseite mit Html5 und Javascript umgesetzt. Die verwendeten Frameworks und zusätzlichen Werkzeuge werden in Kapitel \ref{section:entwicklungsumgebungen_tools} vorgestellt und eingehender beschrieben. Für die Kommunikation mit dem Server verwendet das System REST konforme Anfragen (siehe Kapitel \ref{section:rest}). 
Die Heraustellungsmerkmale von Plesynd sind die Fähigkeit die wichtigsten Funktionalitäten auch offline weiterhin nutzen zu können und die Synchronisierung der Daten, wenn das System wieder online ist. Klassifiziert man diese Fähigkeiten wie in Kapitel \ref{section:klassifizierungsmethoden} beschrieben, so gehören sie in die von Palmér definierte Data-Dimension. Diese Funktionalitäten beschäftigen sich primär mit den Umgang mit Daten und Informationen und den Austausch ebendieser zwischen unterschiedlichen Systemen (zwischen Plesynd und den Widgets) und der Synchronisierung der Daten bei Statusänderung (von Offline- zu Online-Modus). Die Fähigkeit zum Umgang mit unterschiedlichen Status des System kann auch als eine Erweiterung des von Wilson vorgestellten Multimode-Patterns (siehe Seite \pageref{wilson_patterns:multimode}) betrachtet werden. 

Die Möglichkeit Javascript, Css und Html Dateien im Browser zu speichern wurde mit der Html5 Appcache-API umgesetzt (siehe Kapitel \ref{section:appcache}). Für das lokale Speichern der Daten wird Web-Storage und hier insbesondere Local-Storage verwendet (siehe Kapitel \ref{section:offline_storage}). Es wurde in diesem Fall eine Entscheidung gegen die Web-Sql und die IndexedDb-API getroffen. Der Grund dafür war, dass der Web-Storage wie in Abbildung \ref{fig:storage_browser_compatibility} momentan die größte Verbreitung in aktuellen Browsern genießt und für das einfache Hinterlegen von zu synchronisierenden Daten ausreicht. Des weiteren ist der Web-Storage in der Umsetzung und Pflege bedeutet einfacher zu Handhaben als die anderen beiden Systeme. Sollte einmal eine andere Speichertechnik als der Web-Storage benötigt werden, ist das System so implementiert, dass die Art der lokalen Speicherung losgelöst von der restlichen Anwendung umgestaltet werden kann.

Plesynd erkennt über ein globales Javascript-Event (siehe Kapitel \ref{section:online_offline_erkennung}), wenn sich der Browser in einem Zustand befindet, in dem er keine Konnektivität mit dem Internet besitzt. Das System informiert den User darüber, kann aber auch entscheiden, welche Funktionalitäten es dem Nutzer zur Verfügung stellen darf. Nimmt der Anwender Änderungen an den Daten vor, werden diese nur in den Local-Storage geschrieben. Sobald sich das System wieder mit dem Internet verbindet erkennt Plesynd diese Zustandsänderung und synchronisiert die Daten mit den zugrunde liegenden Services. 

Die unterschiedlichen Services werden in Plesynd als Widgets (siehe Kapitel \ref{section:widgets}) eingebunden und von dem Widget-Container Wookie (siehe Kapitel \ref{section:w3c_widgets}) ausgeliefert. Somit ist Plesynd in der Lage alle Widgets, die dem W3C-Standard entsprechen einzubinden. Plesynd hätte genau so mit den OpenSocial Gadgets auf Basis von Shindig implementiert werden können, den Auschlag für die W3C-Widgets und Wookie gaben unterschiedliche, vor allem praktikable Gründe. Das wichtigeste Argument für die Nutzung von W3C-Widgets ist, dass es möglich ist sie als ganz normale Web-Anwendungen zu entwickeln und zu testen. Es ist lediglich notwendig eine gesonderte XML-Konfigurationsdatei mit einigen Parametern zu erstellen. Wookie stellt dann Funktionalitäten zur Verfügung, die es erlauben aus einem einfachen Verzeichnis im Dateisystem ein nach W3C-Spezifikationen gepacktes Widget zu erstellen und dieses auch direkt in Wookie bereitzustellen. Für OpenSocial Gadgets muss der gesamte HTML- und Javascript-Quellcode innerhalb der XML-Datei liegen. Zwar gibt es auch hier Werkzeuge zur Vereinfachung der Gadget-Erstellung, aber der W3C/Wookie-Weg erschien praktikabler. Des weiteren war es zum Zeitpunkt der Entscheidungsfindung um die Dokumentation für die OpenSocial-Seite insbesondere von Shindig eher schlecht bestellt. Viele Verweise auf (z.B. auf Installationanleitungen) führten ins Leere und die PHP-Referenzimplementation war vom Entwicklungsstand ca 1,5 Jahre hinter dem Java System zurück und hatte viele nicht behobene Fehler. Dies scheint sich jedoch zum aktuellen Zeitpunkt geändert und verbessert zu haben. Die Dokumentation von den W3C-Widgets und Wookie waren und sind relativ aktuell und existiert eine funktionierende Implementation der Connector-Api in PHP. Diese konnte als Grundlage für die in Plesynd verwendete Kommunikation mit dem Widget-Container verwendet werden. Aus diesen Gründen viel die Wahl schlussendlich auf die Kombination W3C-Widgets/Wookie.

Probleme mit der bei modernen Browser üblichen Same-Origin-Policy für Request wurden mit dem Cross-Origin Resource Sharing (CORS) Mechanismus (siehe \ref{section:cors}) und die Postmessage-API (siehe \ref{section:kommunikation_zwischen_iframes}) gelöst. Die Offline-Funktionalität des Systems und des Todo-Listen-Widgets wurde im Hinblick auf die Implementierung weiterer Widgets entwickelt. Dies bedeutet, dass auf Basis der vorliegenden Implementierung mit relativ wenig Aufwand weitere Widgets für unterschiedliche Services erstellt werden können. Die Art des Services ist dabei egal, solange er in der Lage ist einfache REST-Anfragen (sieh \ref{section:rest} zu verstehen, zu verarbeiten und standardkonform auf sie zu antworten. Für den Entwickler ist es in diesem Fall vollkommen transparent, ob sich das System in einem Online- oder Offline-Zustand befindet. Er kann unabhängig von dem Zustand die Daten ohne zu implementierende Fallunterscheidungen speichern und abfragen. Damit Plesynd in der Lage ist Widgets zu erkennen, die ebenfall die entwickelte API für Online-/Offline-Anwendungen nutzt, muss in der XML-Konfigurationsdatei für das Widget der Parameter \texttt{plesynd\_offline\_compatible} hinterlegt und auf \texttt{true} gesetzt werden:
\begin{lstlisting}
<preference name="plesynd_offline_compatible" value="true"/>
\end{lstlisting}

\section{Arbeitsablauf}
Im Folgenden wird ein typischer Arbeitsablauf mit Plesynd





